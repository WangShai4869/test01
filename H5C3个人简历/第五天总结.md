# 第五日内容

### 1，函数复习
> 函数调用后，没有return语句，默认返回undefined

> 会具象化传入的数值

```
// f3函数功能：打印传入的第一个参数
function f3() {
console.log(arguments[0]);
}

// 调用f3函数，传入1
f3(1);

// 调用f3函数，传入1 + 1的运算结果
f3(1 + 1);
```
> 总之就是任何数据类型都可以当作实参传入。

### 2，函数调用
```
function fn() {
var obj = {};
return obj;
}
console.log( fn() === fn() );  // false
//在这里是局部变量，两次调用会产生两个执行环境。

/*-------------------------------------------*/

var obj = {};
function f() {
return obj;
}

console.log( f() === f() );  //  true
//这里虽然调用了两次，但是函数f()中并没有定义Obj
只能去全局寻找，而两次调用全部都是调用的是地址。
```
### 3，作用域链

> 作用域链：变量所有的有效区域(运行环境)，统称作用域链。
就比如说全局变量，作用区域就是全局，局部变量的作用域链就是函数内。


### 4，执行环境
>执行环境：
* 说的是代码执行时所依赖的环境。
* 函数被调用一次，就会产生一个执行环境。

### 5，闭包

```
/*
* 闭包：
* 可以访问非自身局部变量的函数。
* 从这种角度来说，函数内的函数才是闭包。
*
* 还有一种说法是，使用了非自身局部变量的函数。
* */

/*
* 以后面试问什么是闭包：
* 可以访问非自身局部变量的函数就是闭包。
* 函数内的函数就是闭包。
* */

```

### 6，变量的生命周期
```
/*
* 全局变量的生命周期：
* 从定义开始，到页面被卸载结束，就是全局变量的生命周期。
* */

// 这个变量，会一直存在，直到页面被卸载

局部变量的生命周期
/*
* 局部变量的生命周期：
* 一般情况下从定义开始，到函数执行完毕结束，就是局部变量的生命周期;
* 但是有二般情况，二般情况可以通过闭包实现。
* */

```
### 7，return数据类型的区别
```
function fn() {
var a = 1;
return a;
}

/*
* fn执行结果是返回一个数值，
* 那么a和a2分别存储返回数值的一个copy版本。
* */
var a = fn();
var a2 = fn();

/*---------------------------------------------*/

function fn() {
var obj = {};
return obj;
}

/*
* fn执行结果是返回一个对象的地址，
* 那么o和o2存储是同一个对象的地址。
* */
var o = fn();
var o2 = fn();

```

### 8，阻止局部变量的释放

> 可以使用闭包的方式阻止局部变量的释放

### 9，闭包操作缓存
```
//    function getDatas() {
//
//        var Data = {};
//
//        function setData(key, val) {
//            Data[key] = val;
//        }
//
//        function getData(key) {
//            return Data[key];
//        }
//
//        return {
//            setdata: setData,
//            getdata: getData
//        }
//    }
//    var fn = getDatas();
//    fn.setdata("name","Chris");
//    console.log(fn.getdata("name"));
```

### 10，闭包操作变量的状态
```
/* var arr = ['第一句话','第二句话','第三句话','第四句话'];
for ( var i = 0, len = arr.length; i < len; i++ ) {
setTimeout(function () {
console.log(arr[i]);
}, 1000);
}*/

/*
* 上面的代码要求，每隔一秒说一句话，找到存在的问题，并解决。
* */

/* var arr = ['第一句话','第二句话','第三句话','第四句话'];
for ( var i = 0, len = arr.length; i < len; i++ ) {
(function () {
var par = i;
setTimeout(function () {
console.log(arr[par]);
}, 1000 * (par + 1));
})();
}*/

var arr = ['第一句话','第二句话','第三句话','第四句话'];
for ( let i = 0, len = arr.length; i < len; i++ ) {
setTimeout(function () {
console.log(arr[i]);
}, 1000 * (i + 1));
}
```



# 第六天

### 上午是复习

### 下午还是复习

>自调函数的作用

防止全局变量污染，过多的全局变量，极易出现冲突和混淆。

> 自调函数的传参

可以提高效率。自调传入window，能有提高效率。

>函数的4种调用模式

* 1，函数调用模式==》函数名（）

* 内部this指向全局对象(window)。

* 2，方法调用模式 ==》对象.函数名（）

* 内部this指向方法所属的对象。

* 3，构造器调用模式 ==》new 函数名（） / new 对象 函数名（）

* 内部this指向新创建的实例。

* 4，间接调用模式==》call（）/apply（）内部this指向自定义对象。

* call（）语法，函数名.call（指定函数执行时的this指向）内部的this会给number string包装成对象。不传或者null会指向window。

### toString可以用来判断内置的十大对象类型（9大构造函数实例+Math）

#### call和apply的区别。

> 语法 call 函数名.call（自定义的this指向，参数1，参数2.。。。。。）
apply（自定义的this指向，[参数1，参数2.。。。。]）

### 函数的4种调用方式总结

>函数中的this是动态变化的，不同的调用方式，this的指向就不同，
说明函数中的this和调用有关，和定义无关。

### 第七天内容